<?xml version="1.0"?>
<package xmlns="http://schemas.microsoft.com/packaging/2013/05/nuspec.xsd">
	<metadata>
		<id>$id$</id>
		<version>$version$</version>
		<title>$title$</title>
		<authors>$author$</authors>
		<owners>$author$</owners>
		<copyright>$copyright$</copyright>
		<description>$description$</description>

		<licenseUrl>https://raw.githubusercontent.com/jjvanzon/JJ.Framework/master/LICENSE.TXT</licenseUrl>
		<projectUrl>https://github.com/jjvanzon/JJ.Framework/tree/master/Framework/Exceptions</projectUrl>
		<iconUrl>https://raw.githubusercontent.com/jjvanzon/JJ.Framework/master/jj-icon-64x64.png</iconUrl>

		<tags>exceptions errors expressions strongly-typed null white space parse type casting not found not unique comparison file folder</tags>

		<dependencies>
			<dependency id="System.ValueTuple" version="4.3.0" />
			<dependency id="JJ.Framework.Text" version="[1.0,1.1)" />
			<dependency id="JJ.Framework.Reflection" version="[1.0,1.1)" />
		</dependencies>

		<summary>
Contains many exception classes for common basic errors, for instance:

* Null errors, null or white space errors, collection contains nulls, etc.
* Parsing errors, type casting errors
* Not found, not unique errors
* Greater than or equal errors and the like
* Files not found, folder already exists, etc.

There are several advantages over using these exception types.

* Error messages are clear.
* Concise syntax, without sacrificing performance.
* You can pass an expression, whose text becomes part of the message.
* Lose no time typing and trying to come up with a good message.

For example:

	throw new NullException(() =&gt; myParent.MyChildren[0].MyProperty);

Will produce an exception message:

	"myParent.MyChildren[0].MyProperty is null."

This is where it surpasses the possibilities of the C#6 nameof operator, which can only mention a name, not a whole expression.

Another example:

	throw new NotFoundException&lt;Customer&gt;(new { customerNumber });

will produce an exception message:

	"Customer with key { customerNumber = 1234 } not found."

As such it is fit for use with any composite key you might have.
			
Some more examples:
			
	throw new NotUniqueException&lt;Product&gt;(productNumber);
	throw new ValueNotSupportedException(myCountryEnumValue);
	throw new FileAlreadyExistsException("text.txt");
	throw new NullOrWhiteSpaceException(() =&gt; myParam.MyProp);

Those produce the exception messages:
			
	height is less than 0.
	Product with key A123 not unique.
	Country value 'Undefined' is not supported.
	File 'test.txt' already exists.
	myParam.MyProp is null or white space.

Here is an example with the value check in it:

	if (height &lt; 0) throw new LessThanException(nameof(height), 0);

This produces the exception message:
				
	height is less than 0.
			</summary>

		<requireLicenseAcceptance>false</requireLicenseAcceptance>
	</metadata>

	<files>
		<file src="README.MD" target="" />
	</files>
</package>