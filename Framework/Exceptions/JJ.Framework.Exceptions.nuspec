<?xml version="1.0"?>
<package xmlns="http://schemas.microsoft.com/packaging/2013/05/nuspec.xsd">
	<metadata>
		<id>$id$</id>
		<version>$version$</version>
		<title>$title$</title>
		<authors>$author$</authors>
		<owners>$author$</owners>
		<copyright>$copyright$</copyright>
		<description>$description$</description>

		<licenseUrl>https://raw.githubusercontent.com/jjvanzon/JJ.Framework/master/LICENSE.TXT</licenseUrl>
		<projectUrl>https://github.com/jjvanzon/JJ.Framework/tree/master/Framework/Exceptions</projectUrl>
		<iconUrl>https://raw.githubusercontent.com/jjvanzon/JJ.Framework/master/jj-icon-64x64-margin4.png</iconUrl>

		<tags>exceptions errors expressions strongly-typed null white space parse type casting found unique comparison file folder</tags>

		<dependencies>
			<dependency id="System.ValueTuple" version="4.3.0" />
			<dependency id="JJ.Framework.Text" version="[1.2,1.3)" />
			<dependency id="JJ.Framework.Reflection" version="[1.2,1.3)" />
		</dependencies>

		<summary>
Contains many exception classes for common basic errors, for instance:

* Null errors, null or white space errors, collection contains nulls, etc.
* Parsing errors, type casting errors
* Not found, not unique errors
* Greater than or equal errors and the like
* Files not found, folder already exists, etc.

There are several advantages over using these exception types.

* Error messages are clear.
* Concise syntax, without sacrificing performance.
* You can pass an expression, whose text becomes part of the message
* Invalid value is automatically mentioned in the exception message.
* Lose no time typing and trying to come up with a good message.

For example:

	throw new NullException(() =&gt; myParent.MyChildren[0].MyProperty);

Will produce an exception message:

	&quot;myParent.MyChildren[0].MyProperty is null.&quot;

This is where it surpasses the possibilities of the C#6 nameof operator, which can only mention a name, not a whole expression.

Another example:

	throw new NotFoundException&lt;Customer&gt;(new { customerNumber, customerType });

will produce an exception message:

	&quot;Customer with key { customerNumber = 1234, customerType = Subscriber } not found.&quot;

As such it is fit for use with any composite key you might have.
			
Some more examples:
			
	throw new NotUniqueException&lt;Product&gt;(productNumber);
	throw new ValueNotSupportedException(myCountryEnumValue);
	throw new FileAlreadyExistsException(&quot;text.txt&quot;);
	throw new NullOrWhiteSpaceException(() =&gt; myParam.MyProp);

Those produce the exception messages:
			
	Product with key A123 not unique.
	Country value &#39;Undefined&#39; is not supported.
	File &#39;test.txt&#39; already exists.
	myParam.MyProp is null or white space.

Here is an example with the value check in it:

	if (height &lt; 10) throw new LessThanException(nameof(height), 10);

This produces the exception message:
				
	height of 2 is less than 10.
			</summary>

		<releaseNotes>
2018-03-07:
* Make exceptions determine whether to show invalid values in messages automatically.
* Subdivide into sub-namespaces.
* Make exceptions take object instead of string, so it can be anonymous type too.
* More useful member summaries.
		</releaseNotes>
		<requireLicenseAcceptance>false</requireLicenseAcceptance>
	</metadata>

	<files>
		<file src="README.MD" target="" />
	</files>
</package>